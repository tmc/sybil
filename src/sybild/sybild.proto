// sybild.proto
//
// This protocol buffer file describes the types and RPC endpoints for
// accessing a sybil database over a network.
syntax = "proto3";
package pb;

import "github.com/golang/protobuf/ptypes/struct/struct.proto";

// Sybil is an OLAP analytics store.
service Sybil {
  // Ingest inserts new data into a sybil dataset.
  rpc Ingest (IngestRequest) returns (IngestResponse) {}
  // Query retrieves results from sybil.
  rpc Query (QueryRequest) returns (QueryResponse) {}
  // ListTables lists the tables in a sybil database.
  rpc ListTables (ListTablesRequest) returns (ListTablesResponse) {}
  // GetTable gets details about a particular table.
  rpc GetTable (GetTableRequest) returns (Table) {}
  // Trim lists and possily removes data exceeding some thresholds.
  rpc Trim (TrimRequest) returns (TrimResponse) {}
}

// IngestRequest inserts records into a sybil dataset.
message IngestRequest {
  string dataset = 1; // dataset is the name of the dataset.
  repeated google.protobuf.Struct records = 2; // records is the set of records to insert.
}

// IngestResponse reports the results of an ingestion request.
message IngestResponse {
  int64 number_inserted = 1; // the numer of inserted records.
}

// QueryType defines the types of query that can be performed.
enum QueryType {
  QUERY_TYPE_UNKNOWN = 0;
  TABLE = 1;
  TIME_SERIES = 2;
  DISTRIBUTION = 3;
  SAMPLES = 4;
}

// QueryOp is the type of operation to perform in the query.
enum QueryOp {
  QUERY_OP_UNKNOWN = 0;
  AVERAGE = 1;
  HISTOGRAM = 2;
}

// QueryFilterOp is the operation to apply to a column as part of a QueryFilter.
enum QueryFilterOp {
  QUERY_FILTER_OP_UNKNOWN = 0;
  RE = 1;
  NRE = 2;
  EQ = 3;
  NEQ = 4;
  GT = 5;
  LT = 6;
  IN = 7;
  NIN = 8;
}

// QueryFilter is a filter on a column.
message QueryFilter {
  string column = 1;
  QueryFilterOp op = 2;
  string value = 3;
}

// QueryRequest describes a query.
message QueryRequest {
  string dataset = 1; // dataset is the name of the dataset.
  QueryType type = 2; // the type of the query.
  int64 limit = 3; // limit number of results.
  repeated string ints = 4; // the integer fields to aggregate.
  repeated string strs = 5; // the string fields to aggregate.
  repeated string group_by = 6; // the fields to group by.
  repeated string distinct_by = 7;
  string sort_by = 8; // field to sort by.
  // todo: prune_by

  string time_column = 9; // column to consider as the time column.
  int64 time_bucket = 10; // time bucket size in seconds.

  string weight_column = 11; // the column to interpret as the weight.

  QueryOp op = 12; // the operation to run.

  repeated QueryFilter int_filters = 13; // filters on int columns.
  repeated QueryFilter str_filters = 14; // filters on string columns.
  repeated QueryFilter set_filters = 15; // filters on set columns.

  HistogramOptions histogram_options = 16; // if type is DISTRIBUTION then this field controls hisogram options.

  bool read_ingestion_log = 17; // if true, the ingestion log is also read to produce results.
  // todo: query cache control?
}

// HistogramType describes the type of histogram.
enum HistogramType {
  HISTOGRAM_TYPE_UNKNOWN = 0;
  NORMAL_HISTOGRAM = 1;
  LOG_HISTOGRAM = 2;
}

// HistogramOptions
message HistogramOptions {
  HistogramType type = 1;
  int64 bucket_size = 2;
}

// QueryResult is the type of the query result.
message QueryResult {
  map<string, Histogram> histograms = 1;
  int64 distinct = 2;

  string group_by_key = 3;
  int64 count = 4;
  int64 samples = 5;
}

// Histogram describes a distribution of values.
message Histogram {
  double mean = 1;
  int64 max = 2;
  int64 min = 3;
  int64 total_count = 4;

  repeated int64 percentiles = 5;
  map<int64, int64> int_buckets = 6;

  int64 range_start = 7;
  int64 range_end = 8;
  double std_deviation = 9;
}

// ResultMap
message ResultMap {
  map<string, QueryResult> values = 1;
}

// SetField
message SetField {
  repeated string values = 1;
}

// Record is an individual record.
message Record {
  map<string, string> strs = 1;
  map<string, int64> ints = 2;
  map<string, SetField> sets = 3;
}

// QueryResults
message QueryResults {
  QueryResult cumulative = 1;
  ResultMap results = 2;
  map<int64, ResultMap> time_results = 3;
  int64 matched_count = 4;
  repeated QueryResult sorted = 5;
  repeated Record matched = 6;
}

// QueryResponse is the response type for a query.
message QueryResponse {
  QueryResults results = 1;
}

// ListTablesRequest requests the list of tables from sybil.
message ListTablesRequest {
}

// ListTablesResponse contains the list of tables in sybil.
message ListTablesResponse {
  repeated string tables = 1;
}

// GetTableRequest requests details about a table.
message GetTableRequest {
  string name = 1;
}

// Table (aka dataset) is a collection of records in a sybil database.
message Table {
  string name = 1;
  repeated string str_columns = 2;
  repeated string int_columns = 3;
  repeated string set_columns = 4;
  int64 count = 5;
  int64 storage_size = 6;
  int64 average_object_size = 7;
}

// TrimRequest queries and optionally removes data from a dataset.
message TrimRequest {
  string dataset = 1; // the name of the dataset.
  string time_column = 2; // the column to interpret as the time column.
  int64 size_limit_mb = 3; // limit, in megabytes, for the dataset.
  int64 time_limit = 4; // limit, in the form a timestamp for the dataset.
  bool delete = 5; // if supplied, actually remove matching blocks.
}

// TrimResponse returns the number of blocks matched by the provided thresholds.
message TrimResponse {
  int64 matched_blocks = 1; // the number of blocks that matched the trim request.
  int64 trimmed_at = 2; // data older than this timestamp matched the trim request. If this doesn't match the provided 'time_limit' then the 'size_limit_mb' field threshold was lower than the 'time_limit' threshold.
}
